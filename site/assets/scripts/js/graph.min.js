// === Slider_c.js ===
//-- Refactored from: https://lgse.github.io/micro-slider

class Slider3D
{
  static default_o =
  {
    //-- classes
    slideList_s:  'slide_list',
    slideFocus_s: 'slide_focus',
    slideTitle_s: 'slide_title',

    step_s:       'step',
    stepList_s:   'step_list',
    stepFocus_s:  'step_focus',

    section_s:    'section',
    scroll_s:     'scroll',

    //:- tags
    slideListTag_s: 'nav',
    slideTag_s:     'dl',
    titleTag_s:     'dt',

    stepListTag_s: 'nav',
    stepTag_s:     'button',

    //:- step_list insertion
    stepBefore_b: false,

    //:- attributes
    hyphen_s:   '-',
    doc_s:   'doc_s',


    clip_b:  false,
    wide_b:  false,

    step_a:  null,
    cycle_f: null,

    padding_n:         0,
    shift_n:           0,
    perspective_n:     30,  //: slides number
    translateWidth_n:  .5,  //: [0...1] : .5 to center
    translateHeight_n: 0,   //: idem
    zoom_n:            -50,
    opac_n:            .05,
    transition_n:      100,
    tick_n:            60,
  }


  constructor
  (
    container_e,
    sectionList_e,
    options_o={}
  )
  {
    this.container_e = container_e
    this.sectionList_e = sectionList_e
    this.option_o = Object.assign( {}, Slider3D.default_o, options_o )

    this.init__v()
  }


  init__v =
  () =>
  {
    this.sectionList = null
    this.slide_e  = null
    this.step_e   = null

    this.slide_a  = []
    this.step_a   = []

    this.slide_n  = 0
    this.atStep_n = 0

    this.listener_b = false
    this.pressed_b  = false
    this.scroll_b   = false
    this.dragX_b    = false
    this.dragY_b    = false

    this.coords_o     = { atX_n: 0, atY_n: 0 }
    this.amplitude_n  = 0
    this.center_n     = 0
    this.lastCenter_n = 0
    this.offset_n     = 0
    this.frame_n      = 0
    this.target_n     = 0
    this.timeout_n    = 0
    this.ticker_n     = 0
    this.stamp_n      = 0
    this.velocity_n   = 0
    ;
    [ 'slide',
      'step',
      'fill',
      'geometry',
      'refresh',
      'listen'
    ]
      .forEach
      (
        method_s =>
          this
            [`${method_s}__v`]()
      )
  }



  setup__v =
  () =>
  {
  }



  slide__v =
  () =>
  {
    this.slideContainer = document.createElement( this.option_o.slideListTag_s )
    this.slideContainer.dataset[this.option_o.hyphen_s] = this.option_o.slideList_s
    this.slideContainer.setAttribute( 'class', this.option_o.slideList_s )
    this.container_e.prepend( this.slideContainer )
  }



  step__v =
  () =>
  {
    this.stepContainer = document.createElement( this.option_o.stepListTag_s )
    this.stepContainer.className = this.option_o.stepList_s
    const method_s = this.option_o.stepBefore_b ? 'prepend' : 'append'
    this.container_e[method_s]( this.stepContainer )
  }


  fill__v =
  () =>
  {
    [...this.sectionList_e.children].forEach(
    ( slot_e, slot_n )  =>
      {
        const skin_n =
          +'-2'
        if ( slot_e.dataset.doc_n > skin_n )        //: skip C_o.SYS_s slots except DOCS_s
        {
          this.addStep__v( slot_e, slot_n )
          this.addSlide__v( slot_e, slot_n )
        }
      } )
  }



  geometry__v =
  () =>
  {
    this.size__v()
    this.perspective__v()
  }



  add__v =
  ( 
    slot_e,
    slot_n=0,
    attribute_a=null,
    callback_f=null
  ) =>
  {
    const slide_n = slot_n || this.slide_n    //: before incrementing
    this.addSlide__v( slot_e, slide_n, attribute_a )
    this.addStep__v( slot_e, slide_n )
    this.geometry__v()
    this.refresh__v()
    callback_f && callback_f()
  }



  addSlide__v =
  (
    slot_e,
    slide_n,
    attribute_a=null
  ) =>
  {
    const slide_e = document.createElement( this.option_o.slideTag_s )
    slide_e.dataset[this.option_o.step_s] = slide_n
    //xxslide_e.dataset[this.option_o.section_s] = slot_e.dataset.doc_n
    slide_e.dataset[this.option_o.section_s] = slot_e.dataset.doc_n
    const title_s =
      slot_e
        .dataset[this.option_o.doc_s]
        .replaceAll( '_', ' ' )
    slide_e.innerHTML =
      `<${this.option_o.titleTag_s} class="${this.option_o.slideTitle_s}">${title_s}</${this.option_o.titleTag_s}>`
    if ( attribute_a )
    {
      for ( const at_s of attribute_a )
      {
        const [ name_s, value_s ] = at_s.split( '=' )
        slide_e.setAttribute( name_s, value_s )
      }
    }
    //... const title_e = document.createElement( this.option_o.titleTag_s )
    this.slideContainer.appendChild( slide_e )
    this.slide_a.push( slide_e )
    this.slide_n = this.slide_a.length
  }



  addStep__v =
  (
    slot_e,
    slide_n
  ) =>
  {
  const step_e = document.createElement( this.option_o.stepTag_s )
  step_e.dataset[this.option_o.step_s] = slide_n
  const title_s = slot_e.dataset[this.option_o.doc_s]
  step_e.setAttribute( 'title', title_s )
  if ( slide_n === 0 )
  {
    this.step_e = step_e
    step_e.classList.add(this.option_o.stepFocus_s)
  }
  step_e.addEventListener( 'click', _o => this.toCurrent__v( slide_n ) )
  this.stepContainer.appendChild( step_e )
  this.step_a.push( step_e )
  }



  capacity__n =
  () =>
  { return this.slide_a.length }

  

  size__v =
  () =>
  {
    if ( !this.slide_a.length ) return
    //>
    const slide_e = this.slide_a[0]
    this.dimension__v( `${slide_e.offsetHeight}px`, `${slide_e.offsetWidth}px` )
  }



  dimension__v =
  (
    height_n='100px',
    width_n='100px'
  ) =>
  {
    this.dimension_o = { width_n: parseInt( width_n ), height_n: parseInt( height_n ) }
    this.size_n = ( this.dimension_o.width_n * 2 ) + this.option_o.padding_n
  }
  

  
  perspective__v =
  () =>
  {
    this.slideContainer.style.perspective =
      this.option_o.wide_b ?
      'none' :
      `${this.dimension_o.height_n * this.option_o.perspective_n}px`
  }



  position__n =
  (
    event_o,
    axis_s    //: axis_s is 'X' || 'Y'
  ) =>
  {
    let position_n = event_o[`client${axis_s}`]
    if ( event_o.targetTouches &&
        (event_o.targetTouches.length >= 1 ) ) position_n = event_o.targetTouches[0][`client${axis_s}`]
    return position_n
  }



  clip__n =
  (
    clip_n
  ) =>
  {
    const at_n = this.slide_n
    return ( clip_n >= at_n ) ?
      clip_n % at_n
      : ( clip_n < 0 ) ?
        this.clip__n( at_n + ( clip_n % at_n ) )
          : clip_n
  }



  closest__o =
  (
    item_e
  ) =>
  {
    if ( item_e.dataset[this.option_o.step_s] ) return item_e
    //>
    let parent = null
    while ( item_e )
    {
      parent = item_e.parentElement
      if ( parent && parent.dataset[this.option_o.step_s] ) return parent
      //>
      item_e = parent
    }
    return parent
  }



  current__n =
  (
    item_e
  ) =>
  {
    const step_n = item_e.dataset[this.option_o.step_s]
    const slide_e = this.slide_a.find( slide_e => slide_e.dataset[this.option_o.step_s] === step_n )
    return !slide_e ?
      '0'
      : slide_e.dataset[this.option_o.step_s]
  }



  atStep__v =
  () =>
  {
    if ( this.step_e !== this.step_a[this.atStep_n] )
      {
      this.step_e.classList.remove( this.option_o.stepFocus_s )
      this.step_e = this.step_a[this.atStep_n]
      this.step_e.classList.add( this.option_o.stepFocus_s )
      this.step_e.focus()
    }
  }



  atStep__n =
  () =>
  { return this.atStep_n }



  nearest__v =
  (
    shift_n
  ) =>
  {
    if ( !this.listener_b ) return
    this.target_n = ( this.size_n * Math.round( this.offset_n / this.size_n ) ) +
      ( this.size_n * shift_n )
    if ( this.offset_n !== this.target_n )
    {
      this.amplitude_n = this.target_n - this.offset_n
      this.stamp_n = performance.now()
      requestAnimationFrame( this.frame__v )
    }
  }



  toCurrent__v =
  (
    to_n
  ) =>
  { return this.cycle__v( to_n ) }



  toNearest__v =
  (
    shift_n
  ) =>
  {
    const to_n = this.atStep_n + shift_n
    if ( !this.option_o.clip_b || ( this.option_o.clip_b && to_n >= 0 ) ) this.cycle__v( to_n )
  }



  toSlide__v =
  (
    slide_e
  ) =>
  {
    if ( !slide_e.classList.contains( this.option_o.slideFocus_s ) )
    {
      if ( this.slide_e !== null ) this.slide_e.classList.remove( this.option_o.slideFocus_s )
      this.slide_e = slide_e
      this.atStep_n = this.current__n( slide_e )
      if ( !this.slide_e.classList.contains( this.option_o.slideFocus_s ) )
      {
        this.slide_e.classList.add(this.option_o.slideFocus_s)
      }
    }
    this.atStep__v()
  }



  cycle__v =
  (
    to_n
  ) =>
  {
    let offset_n = ( this.center_n % this.slide_n ) - to_n
    if ( !this.option_o.clip_b )
    {
      if ( offset_n < 0 && ( Math.abs( offset_n + this.slide_n ) < Math.abs( offset_n ) ) )
      {
        offset_n += this.slide_n
      } else if ( offset_n > 0 && ( Math.abs( offset_n - this.slide_n ) < offset_n ) )
      {
        offset_n -= this.slide_n
      }
    }
    return void ( offset_n < 0 ) ?
      this.nearest__v( Math.abs( offset_n ) )
      : this.nearest__v( -offset_n )
  }



  listen__v =
  (
    listener_b=false
  ) =>
  {
    let method_s = `${!listener_b ? 'add' : 'remove'}EventListener`
    //:- Touch Events
    if ( typeof window.ontouchstart !== 'undefined' )
    {
      this.container_e[method_s]( 'touchstart', this.tap__v )
      this.container_e[method_s]( 'touchmove', this.drag__v )
      this.container_e[method_s]( 'touchend', this.release__v )
    }
    //:- Mouse Events
    this.container_e[method_s]( 'click', this.click__v )
    this.container_e[method_s]( 'mousedown', this.tap__v )
    this.container_e[method_s]( 'mousemove', this.drag__v )
    this.container_e[method_s]( 'mouseup', this.release__v )
    this.container_e[method_s]( 'mouseleave', this.release__v )
    //:- Resize Event
    window[method_s]( 'resize', this.resize__v )
    this.listener_b = listener_b === false
  }
  


  click__v =
  (
    click_o
  ) =>
  {
    if ( !this.listener_b ) return
    //>
    const target_e =
      click_o
        .target
        .closest( `${this.option_o.slideTag_s}[data-${this.option_o.step_s}]` )
    if ( !target_e ) return
    //>
    if ( this.dragY_b ) return void click_o.stopPropagation()
    //>
    if ( !this.option_o.wide_b )
    {
      const closest_e = this.closest__o( click_o.target )
      if ( !closest_e ) return
      //>
      const index_n = this.current__n( closest_e )
      const offset_n = ( this.center_n % this.slide_n ) - index_n
      if ( offset_n !== 0 ) click_o.stopPropagation()
      this.cycle__v( index_n )
    }
  }



  tap__v =
  (
    tap_o
  ) =>
  {
    if ( !this.listener_b ) return
    //>
    this.pressed_b = true
    this.dragX_b = false
    this.dragY_b = false
    this.velocity_n = 0
    this.amplitude_n = 0
    this.frame_n = this.offset_n
    this.stamp_n = performance.now()
    this.coords_o = { atX_n: this.position__n( tap_o, 'X' ), atY_n: this.position__n( tap_o, 'Y' ) }
    clearInterval( this.ticker_n )
    this.ticker_n = setInterval( this.track__v, this.tick_n )
  }



  drag__v =
  (
    drag_o
  ) =>
  {
    if ( !this.listener_b ) return
    //>
    if ( drag_o.target.classList.contains( this.slideFocus_s ) ) return
    //>
    if ( this.pressed_b )
    {
      const atX_n = this.position__n( drag_o, 'X' )
      const atY_n = this.position__n( drag_o, 'Y' )
      const deltaX_n = this.coords_o.atX_n - atX_n
      const deltaY_n = Math.abs( this.coords_o.atY_n - atY_n )
      if ( deltaY_n < 30 && !this.dragX_b )
      {
        if ( deltaX_n > 2 || deltaX_n < -2 )
        {
          this.dragY_b = true
          this.coords_o.atX_n = atX_n
          this.scroll__v( this.offset_n + deltaX_n )
        }
      }
      else
      {
        if ( this.dragY_b ) return void drag_o.stopPropagation()
        //>
        this.dragX_b = true
      }
    }
    if ( this.dragY_b ) drag_o.stopPropagation()
  }



  release__v =
  (
    release_o
  ) =>
  {
    if ( !this.pressed_b ) return
    //>
    this.pressed_b = false
    clearInterval( this.ticker_n )
    this.target_n = this.offset_n
    if ( this.velocity_n > 10 || this.velocity_n < -10 )
    {
      this.amplitude_n = 0.9 * this.velocity_n
      this.target_n = this.offset_n + this.amplitude_n
    }
    this.target_n = Math.round( this.target_n / this.size_n ) * this.size_n
    if ( this.option_o.clip_b )
    {
      if ( this.target_n >= this.size_n * ( this.slide_n - 1 ) )
      {
        this.target_n = this.size_n * ( this.slide_n - 1 )
      } else if ( this.target_n < 0 )
      {
        this.target_n = 0
      }
    }
    this.amplitude_n = this.target_n - this.offset_n
    this.stamp_n = performance.now()
    requestAnimationFrame( this.frame__v )
    if ( this.dragY_b ) release_o.stopPropagation()
  }



  resize__v =
  () =>
  {
    if ( !this.listener_b ) return
    //>
    if ( this.option_o.wide_b )
    {
      this.size__v()
      //XX this.offset_n = this.center_n * 2 * this.dimension_o.width_n
      this.offset_n = this.center_n * 2 * this.dimension_o.height_n
      this.target_n = this.offset_n
      return
    }
    this.geometry__v()
    this.scroll__v()
  }



  track__v =
  () =>
  {
    let now_n = performance.now()
    let elapsed_n = now_n - this.stamp_n
    this.stamp_n = now_n
    let delta_n = this.offset_n - this.frame_n
    this.frame_n = this.offset_n
    const speedup_n = 1000 * delta_n / ( 1 + elapsed_n )
    this.velocity_n = 0.8 * speedup_n + 0.2 * this.velocity_n
  }



  translate__v =
  (
    slide_e,
    zindex_n,
    opac_n,
    x1_n,
    z1_n,
    x2_n = null
  ) =>
  {
    let toX_n = x1_n    //: horizontal
    let toY_n = 0       //: horizontal
    //XX let toX_n = 0
    //XX let toY_n = x1_n
    if ( !this.option_o.wide_b )
    {
      const width_n = (this.container_e.clientWidth - this.dimension_o.width_n) * this.option_o.translateWidth_n
      const height_n = (this.container_e.clientHeight - this.dimension_o.height_n) * this.option_o.translateHeight_n
      toX_n += width_n     //: horizontal
      toY_n += height_n    //: horizontal
      //XX toX_n += height_n
      //XX toY_n += width_n
    }
    if ( x2_n !== null ) toX_n += x2_n    //: horizontal
    //XX if ( x2_n !== null ) toY_n += x2_n
    slide_e.style.transform = `translate3d( ${toX_n}px, ${toY_n}px, ${z1_n}px )`    //: horizontal
    //XX slide_e.style.transform = `translate3d( ${toX_n}px, ${toY_n}px, ${z1_n}px )`
    slide_e.style.zIndex = zindex_n
    slide_e.style.opacity = opac_n
  }
  


  scroll__v =
  (
    shift_n=0
  ) =>
  {
    let slide_e
    let opac_n
    let translateZ_n
    let at_n = 0
  
    this.timeout__v()
    //:- Compute Scroll
    this.lastCenter_n = this.center_n
    this.offset_n = (typeof shift_n === 'number') ? shift_n : this.offset_n
    this.center_n = Math.floor( ( this.offset_n + this.size_n * .5 ) / this.size_n )
    const delta_n = this.offset_n - this.center_n * this.size_n
    const directional_n = ( delta_n < 0 ) ? 1 : -1
    const tween_n = -directional_n * delta_n * 2 / this.size_n
    const half_n = this.slide_n >> 1
    //:- Center Item Positioning
    if ( !this.option_o.clip_b || ( this.center_n >= 0 && this.center_n < this.slide_n ) )
    {
      slide_e = this.slide_a[this.clip__n( this.center_n )]
      this.toSlide__v( slide_e )
      this.translate__v(
        slide_e,
        0,
        this.option_o.wide_b ? 1 : 1 - this.option_o.opac_n * tween_n,
        -delta_n >> 1,
        this.option_o.zoom_n * tween_n,
        directional_n * this.option_o.shift_n * tween_n * at_n
        )
    }
    //:- Iterate through all slider items and position them
    for ( at_n = 1; at_n <= half_n; ++at_n )
    {
      //:- Left slides positioning
      if ( this.option_o.wide_b )
      {
        translateZ_n = this.option_o.zoom_n
        opac_n = ( at_n === half_n && delta_n > 0 ) ? 1 - tween_n : 1
      }
      else
      {
        translateZ_n = this.option_o.zoom_n * ( at_n * 2 - tween_n * directional_n )
        opac_n = 1 - this.option_o.opac_n * ( at_n * 2 - tween_n * directional_n )
      }
      //:- Hide clipped slides
      if ( !this.option_o.clip_b || this.center_n - at_n >= 0 )
      {
        slide_e = this.slide_a[this.clip__n( this.center_n - at_n )]
        this.translate__v(
          slide_e, -at_n, opac_n,
          -this.option_o.shift_n + ( ( -this.size_n * at_n - delta_n ) >> 1 ),
          translateZ_n
          )
      }
      //:- Right items positioning
      if ( this.option_o.wide_b )
      {
        translateZ_n = this.option_o.zoom_n
        opac_n = ( at_n === half_n && delta_n < 0 ) ? 1 - tween_n : 1
      }
      else
      {
        translateZ_n = this.option_o.zoom_n * ( at_n * 2 + tween_n * directional_n )
        opac_n = 1 - this.option_o.opac_n * ( at_n * 2 + tween_n * directional_n )
      }
      //:- Hide clipped slides
      if ( !this.option_o.clip_b || this.center_n + at_n < this.slide_n )
      {
        slide_e = this.slide_a[this.clip__n( this.center_n + at_n )]
        this.translate__v(
          slide_e,
          -at_n,
          opac_n,
          this.option_o.shift_n + ( this.size_n * at_n - delta_n ) * .5,
          translateZ_n
          )
      }
    }
    //:- Callback
    if ( this.lastCenter_n !== this.center_n && typeof( this.option_o.cycle_f) === 'function' )
    {
      this.option_o.cycle_f.call( this, this.slide_e, this.dragY_b )
    }
  }



  timeout__v =
  () =>
  {
    this.scroll_b = true
    if ( this.container_e.classList.contains( this.option_o.scroll_s ) ) this.container_e.classList.add( this.option_o.scroll_s )
    if ( this.timeout_n !== 0 ) window.clearTimeout( this.timeout_n )
    this.timeout_n = window.setTimeout(
      () =>
      {
        this.scroll_b = false
        this.container_e.classList.remove( this.option_o.scroll_s )
      },
      this.option_o.transition_n )
  }



  frame__v =
  () =>
  {
    if ( !this.amplitude_n ) return
    //>
    const elapsed_n = performance.now() - this.stamp_n
    const delta_n = this.amplitude_n * Math.exp( -elapsed_n / this.option_o.transition_n )
    if ( delta_n > 2 || delta_n < -2 )
    {
      this.scroll__v( this.target_n - delta_n )
      requestAnimationFrame( this.frame__v )
      return
    }
    this.scroll__v( this.target_n )
  }



  refresh__v =
  () =>
  {
    requestAnimationFrame( this.frame__v )
    this.resize__v()
    this.scroll__v()
  }



  wide__v =
  (
    wide_b        = false,
    slideWidth_n  = 200,
    slideHeight_n = null
  ) =>
  {
    let height_s = slideHeight_n === null ? `${this.dimension_o.height_s}px` : `${slideHeight_n}px`
    let width_s = wide_b ? '100%' : `${slideWidth_n}px`
    this.option_o.wide_b = wide_b
    this.dimension__v( height_s, width_s )
    this.perspective__v()
    this.refresh__v()
  }


  
  detach__v =
  () =>
  { this.listen__v( true ) }
}


// === SLI_o: slider.js ===
var SLI_o =
{
  slider_e: null,
  slider_c: null,


  slider__n    //: init Slider3D & setup slide[0] data-section
  ()
  {
    SLI_o.slider_e =
      LIB_o
        .nodeId__o( 'sections_slider' )
    SLI_o
      .slider_c =
        new Slider3D(
          SLI_o.slider_e,
          LIB_o.nodeId__o( 'sections' )
          )
    return (
      SLI_o
        .slider_c
        .capacity__n()
      )
  }  
,


  section__v    //:- change view to section
  (
    event_o
  )
  {
    const step_e =
      event_o
        .target
        .closest( '[data-step]' )
    if ( step_e )
    {
      const step_n =
        +step_e
          .dataset
          .step
      const doc_n =
        +LIB_o
          .nodeId__o( 'sections_slider' )
          .querySelector( `dl[data-step="${step_n}"]` )
          .dataset
          .section
      SLI_o
        .location__v
        (
          LIB_o
            .docS__o( doc_n )
        )
    }
  }
,



  remove__v
  ()
  {
    LIB_o
      .resetNode__o( 'sections_slider' )
    SLI_o
      .slider_c
      .init__v()
  }
,


  
  location__v
  (
    doc_s
  )
  {
    document
      .querySelector( `section[data-doc_s="${doc_s}"]` )
      .scrollIntoView( {behavior: "smooth", block: "start"} )
    //?? window
    //??   .location
    //??   .hash = `#${doc_s}`
  }
,



  listen__v
  ()
  {
    SLI_o
      .slider_e
      .addEventListener( 'click', SLI_o.section__v )
    //?? SLI_o.slider_e.addEventListener( 'touchstart', SLI_o.section__v )
    
    //: keyboard
    /*
    document.addEventListener( 'keyup',
      key_o =>
      {
        if ( key_o.defaultPrevented || !SLI_o.onv}iew__b() ) return
        //>
        const key_sn = key_o.key || key_o.keyCode
        if ( [ 'Escape', 'Esc', 27 ].includes( key_sn ) ||
             [ 'Backspace', 'Back', 8 ].includes( key_sn ) ) SLI_o.onview__s()    // ESC || BACKSPACE close
        else
        {
          switch ( true )
          {
            case ( [ 'ArrowLeft', 'Left', 37 ].includes( key_sn ) ) :    //: LEFT
              SLI_o.slider_c.toNearest__v( -1 )
              break
            case ( [ 'ArrowRight', 'Right', 39 ].includes( key_sn ) ) :    //: RIGHT
              SLI_o.slider_c.toNearest__v( 1 )
              break
            case ( [ 'ArrowUp', 'Up', 38 ].includes( key_sn ) ) :    //: UP
              SLI_o.slider_c.toNearest__v( -4 )
              break
            case ( [ 'ArrowDown', 'Down', 40 ].includes( key_sn ) ) :    //: DOWN
              SLI_o.slider_c.toNearest__v( 4 )
              break
            case ( [ 'Enter', 13 ].includes( key_sn ) ) :    //: ENTER
              SLI_o.onview__s()
              break
            default:
              break
          }
        }
        key_o.preventDefault()
        key_o.stopPropagation()
      }, true )
    */
    
  }
,

}


void function
()
{
  LIB_o
    .rootVar__v( '--SECTIONS_CAP', SLI_o.slider__n() )
  SER_o
    .send__v
    (
      'RESTORE',
      null
    )
  SLI_o
    .listen__v()
  //>
  ;console.log( 'slider.js' )
} ()


// === PAN_o: pan.js ===

var PAN_o =
{
  gapX_n:      0,
  gapY_n:      0,
  offsetX_n:   0,
  offsetY_n:   0,
  x_n:         0,
  y_n:         0,
  move_b:      false,

  scale_n:     1.0,
  ratio_n:     -.01,
  minScale_n:  .1,
  maxScale_n:  10,
  panMove_n:   10,
  zoomScale_n: 10,



  init__v
  (
    target_s,
    dimension_a,
    options_o={}    //: { zoom_b: false ||true, pan_b: false ||true }
  )
  {
    PAN_o.target_e  = document.querySelector( target_s )
    PAN_o.target__v( dimension_a )
    if ( options_o.zoom_b ) PAN_o.listenZoom__v()
    if ( options_o.pan_b ) PAN_o.listenPan__v()
  }
,



  target__v    //: Set geometry constants
  (
    dimension_a  //: if only 2 dimensions, viewport = viewbox
  )
  {
    PAN_o.target_e.width  = PAN_o.width_n  = dimension_a[0]
    PAN_o.target_e.height = PAN_o.height_n = dimension_a[1]
    PAN_o.minX_n = dimension_a[2] || dimension_a[0]
    PAN_o.minY_n = dimension_a[3] || dimension_a[1]
    PAN_o.viewbox__v( 0, 0, PAN_o.width_n, PAN_o.height_n )
  }
,



  viewbox__v    //: Set SVG viewbox dimensions
  (
    minX_n,
    minY_n,
    width_n,
    height_n
  )
  { PAN_o.target_e.setAttribute( 'viewBox', `${minX_n} ${minY_n} ${width_n} ${height_n}` ) }
,



  viewbox__a      //: Get SVG viewbox dimensions
  ()
  { return PAN_o.target_e.getAttribute( 'viewBox' ).split( ' ' ) }
,



  listenZoom__v      //: Set zoom event listeniers
  ()
  { [ 'wheel', 'touchstart', 'keydown' ].forEach( type_s => PAN_o.listen__v( type_s, 'Zoom' ) ) }
,



  wheelZoom__v
  (
    event_o
  )
  { PAN_o.viewbox__v( ...PAN_o.scale__a( event_o.deltaY < 0 ? PAN_o.zoomScale_n : -PAN_o.zoomScale_n ) ) }
,



  touchstartZoom__v
  (
    event_o
  )
  {
    if ( event_o.touches.length < 2 ) return void PAN_o.touchstartStart__v( event_o )
    //>
    PAN_o.viewbox__v( ...PAN_o.scale__a( event_o.touches.length > 2 ? PAN_o.zoomScale_n : -PAN_o.zoomScale_n ) )
  }
,



  keydownZoom__v:
  (
    event_o
  ) =>
  {
    const code_n = event_o.keyCode
    if ( code_n === 107  || code_n === 109 )    //: NumPadPlus || NumPadMinus
      PAN_o.viewbox__v( ...PAN_o.scale__a( code_n === 109 ? -PAN_o.zoomScale_n : code_n === 107 ? PAN_o.zoomScale_n : 0 ) )  //: no zoom if 0
  }
,



  listenPan__v      //: Set pan event listeniers
  ()
  { [ 'mousedown', 'keydown' ].forEach( type_s => PAN_o.listen__v( type_s, 'Start' ) ) }    //: no touchstart (handled in touchstartZoom__v )
    
,



  mousedownStart__v
  (
    event_o
  )
  { return PAN_o.panStart__v( ...PAN_o.client__a( event_o ), ...PAN_o.handle__a( event_o ) ) }
,



  touchstartStart__v    //: event handle from touchstartZoom__v
  (
    event_o
  )
  { if ( event_o.touches.length < 2 ) PAN_o.panStart__v( ...PAN_o.client__a( event_o ), ...PAN_o.handle__a( event_o ) ) }
,



  keydownStart__v
  (
    event_o
  )
  {
    const code_n = event_o.keyCode
    if ( PAN_o.move_b && code_n >= 37 && code_n <= 40 ) return void PAN_o.panMove__v( event_o )    //: Arrows
    if ( code_n === 32 ) return void PAN_o.panStart__v( ...PAN_o.client__a( event_o ), ...PAN_o.handle__a( event_o ) )    //: Spacebar
    if ( code_n === 13 ) return void PAN_o.panStop__v( event_o )    //: Enter
  }
,



  panStart__v
  (
    atX_n,
    atY_n,
    move_s,
    stop_s
  )
  {
    PAN_o.move_b = true
    const [ minX_s, minY_s ] = PAN_o.viewbox__a()
    PAN_o.gapX_n = atX_n - PAN_o.offsetX_n
    PAN_o.gapY_n = atY_n - PAN_o.offsetY_n
    PAN_o.gapX_n = atX_n - -minX_s
    PAN_o.gapY_n = atY_n - -minY_s
    PAN_o.target_e.addEventListener( move_s, PAN_o.panMove__v, false)
    PAN_o.target_e.addEventListener( stop_s, PAN_o.panStop__v, false)
  }
,




  panMove__v
  (
    event_o
  )
  {
    if ( PAN_o.move_b )
    {
      const [ clientX_n, clientY_n ] = PAN_o.client__a( event_o )
      PAN_o.x_n = clientX_n - PAN_o.gapX_n
      PAN_o.y_n = clientY_n - PAN_o.gapY_n
      PAN_o.offsetX_n = PAN_o.x_n
      PAN_o.offsetY_n = PAN_o.y_n
      const [ minX_s, minY_s, width_s, height_s ] = PAN_o.viewbox__a()
      PAN_o.viewbox__v( ''+-PAN_o.x_n, ''+-PAN_o.y_n, width_s, height_s )
    }
  }
,




  panStop__v
  (
    event_o
  )
  {
    PAN_o.move_b = false
    const [ move_s, stop_s ] = PAN_o.handle__a( event_o )
    PAN_o.target_e.removeEventListener( move_s, PAN_o.panMove__v, false)
    PAN_o.target_e.removeEventListener( stop_s, PAN_o.panStop__v, false)
  }
,



  scale__a        //: Get [String] for SVG viewBox geometry
  (
    scale_n
  )
  {
    PAN_o.scale_n =    //: update scale_n
      Math.min(Math.max( PAN_o.minScale_n, PAN_o.scale_n + ( scale_n * PAN_o.ratio_n ) ), PAN_o.maxScale_n )
    const width_n = Math.round(PAN_o.scale_n * PAN_o.width_n )
    const height_n = Math.round(PAN_o.scale_n * PAN_o.height_n )
    const [ minX_s, minY_s ] = PAN_o.viewbox__a()
    return [ minX_s, minY_s, ''+width_n, ''+height_n ]
  }
,



  client__a
  (
    event_o
  )
  {
    if ( event_o.clientX !== undefined ) return [ event_o.clientX, event_o.clientY ]    //: mouse event
    if ( event_o.changedTouches !== undefined ) return [ event_o.changedTouches[0].clientX, event_o.changedTouches[0].clientY ]    //: touch event
    if ( event_o.keyCode )    //: keyboard event
    {
      const code_n = event_o.keyCode
      const gapX_n = code_n === 37 ? -PAN_o.panMove_n : code_n === 39 ? PAN_o.panMove_n : 0
      const gapY_n = code_n === 38 ? -PAN_o.panMove_n : event_o.keyCode === 40 ? PAN_o.panMove_n : 0
      return [ gapX_n + PAN_o.x_n, gapY_n + PAN_o.y_n ]
    }
    return [0, 0] //: no move if undefined event
  }
,



  listen__v
  (
    type_s,
    method_s
  )
  {
    const target_e = type_s === 'keydown' ? document : PAN_o.target_e    //: SVG element is not an input element: use document element
    target_e.addEventListener
      (
        type_s,
        event_o =>
        {
          event_o.preventDefault()
          PAN_o[`${type_s}${method_s}__v`]( event_o )
        }
      )
  }
,



  handle__a
  (
    event_o
  )
  {
    if ( event_o.clientX !== undefined ) return [ 'mousemove', 'mouseup' ]    //: mouse event
    if ( event_o.changedTouches !== undefined ) return [ 'touchmove', 'touchend' ]    //: touch event
    return [ 'keydown', 'keydown' ]    //: keyboard event
  }
,


}


// === SET_o: sets.js ===
//-> export
var SET_o =
{
  
  
  disjoint__a  //:- create 2 disjoint Integer Sets by comparing 2 Integers Sets
  (
    ref_a,    //:- Set( int )
    comp_a    //:- Set( int )
  )
  {
    const set_a =
      [
        new Set(),
        new Set()
      ]
    ref_a
      .forEach
      ( 
        ref_n =>
        {
          if ( !comp_a.has( ref_n ) )
            set_a[0]
              .add( ref_n )
        }
      )
    comp_a
      .forEach
      ( 
        comp_n =>
        {
          if ( !ref_a.has( comp_n ) )
            set_a[1]
              .add( comp_n )
        }
      )
    //-->
    return set_a
  }
,
}


// === GRA_o: graph.js ===

var GRA_o =
{
  graph_c:  null,
  dim_n: 24,
  gap_n: 2,
  minDim_n: 16,
  maxDim_n: 32,
  node_s: 'node_',

  slider_e: null,
  svg_e: null,
  selected_a: new Set(),


  
  async fetch__v
  (
    url_s
  )
  {
    let fetch_o =
      await fetch
      (
        url_s
      )
    if ( !fetch_o.ok ) return void alert( `"HTTP-Error: ${fetch_o.status}` )  //!!! TODO: better alert
    //-->
    const json =
      await fetch_o
        .json()
    //-->
    return json
  }
,




  nodes__v    //:- select topic grid nodes
  (
    event_e
  )
  {
    const target_e =
      event_e
        .target
        .closest( '[data-step]' )

    if ( target_e && target_e.classList.contains( 'slide_focus' ) )
    {
      LIB_o
        .invisible__v
        (
          GRA_o.svg_e
        )

      const at_n =
        GRA_o
          .slider_c
          .atStep__n()

      const topic_e =
        LIB_o
          .nodeId__o( 'topics_docs' )
          .querySelector( `li[data-doc_n="${at_n}"]` )

      const docs_a =
        new Set
        (
          topic_e
            .dataset['-']
            .split( ' ' )
        )

      SET_o
        .disjoint__a
        (
          GRA_o.selected_a,
          docs_a
        )
        .forEach
        (
          at_a =>
            GRA_o
              .toggle__v( at_a )
        )
        
      GRA_o
        .selected_a = docs_a
    }
  }
,



  toggle__v
  (
    set_a
  )  
  {
    set_a
      .forEach
      (
        at_n =>
        {
          const at_e =
            GRA_o
              .svg_e
              .querySelector( `circle:nth-child(${at_n})` )    //-- rect
          at_e &&
            at_e
              .classList
              .toggle( 'node_set' )
        }
      )  
  }    
,  



  nodeOpen__v    //:- diplay node data
  (
    event_e
  )
  {
    const target_e =
      event_e
        .target
    GRA_o
      .node__v
      (
        target_e,
        target_e.classList.contains( 'node_set' )
      )
    SLOT_o
      .dialog__o( 'section_contents' )
      .classList
      .toggle( 'retract' )
    const node_e =
      GRA_o
        .svg_e
        .querySelector( '.node_focus' )
    if ( node_e )    //: deselect previous focused node
    {
      node_e
       .classList
       .remove( 'node_focus' )
    }
    target_e    //: select new focused node
      .classList
      .add( 'node_focus' )
  }
,



  nodeClose__v
  ()
  {
    SLOT_o
      .dialog__o( 'section_contents' )
      .classList
      .toggle( 'retract' )
  }
,



  sectionSlider__v
  ()
  {
    SLI_o
      .slider_c
      .cycle__v( SLI_o.slider_c.capacity__n() - 1 )
  }
,



  nodeLink__v
  ()
  {
    const step_s =
      GRA_o
        .nodeStep__s()
    const doc_s =
      GRA_o
        .nodeSlot__s( step_s )
    let section_e =
      LIB_o
        .nodeId__o( 'sections' )
        .querySelector
        (
          `section[data-doc_n="${step_s}"]`
          //...`section[data-doc_n="${+step_s + 1}"]`              //: Number cast
        )
    if ( !section_e )  //: not yet fetched
    {
      IND_o
        .load__v
        (
          'slots',      //: path_s default
          doc_s,
          +step_s,        //: as Number
          section_e =>    //: callback_f
          {
            SLI_o
              .slider_c
              .add__v
              (
                section_e,
                0,    //: NOT auto indexed
                [
                  `data-doc_s=${section_e.dataset.doc_s}`
                ],
                () =>    //: callback_f
                {
                  GRA_o
                    .sectionSlider__v()
                  LIB_o
                    .rootVar__v
                    (
                      '--SECTIONS_CAP',
                      SLI_o.slider_c.capacity__n()
                    )
                }
              )
          }
        )
      }
    GRA_o.nodeClose__v()
  }
,



  nodeStep__s
  ()
  {
    return (
      LIB_o
        .id__o
        (
          'dialog_block_title',
          SLOT_o
            .dialog__o( 'section_contents' )
        )
        //XX.getAttribute( 'data-doc_s' )  //: set by node__v
        .dataset.doc_s  //: set by node__v
        .slice( 'node_'.length )
    )
  }
,



  nodeSlot__s
  (
    step_s
  )
  {
    return LIB_o
      .nodeId__o( 'docs_topics' )
      .querySelector( `li[data-doc_n="${step_s}"]` )
      .dataset.doc_s
  }
,



  node__v
  (
    node_e,
    selected_b
  )
  {
    const at_n =
      +node_e    //: number cast
        .id
        .slice
        (
          GRA_o
            .node_s
            .length
        )
    const topics_e =
      LIB_o
        .nodeId__o( 'docs_topics' )
    const data_e =
      topics_e
        .querySelector( `li[data-doc_n="${at_n}"]` )
    if ( !data_e ) return
    //>
    const section_e =
      SLOT_o
        .dialog__o( 'section_contents' )
    const title_e =
      LIB_o
        .id__o
        (
          'dialog_block_title',
          section_e
        )
    title_e
      .setAttribute
      (
        'data-doc_s',
        node_e.id
      )
    title_e
      .innerHTML =
        data_e
          .dataset
          .doc_s
          .replaceAll
          (
            '_',
            ' '
          )
    const topics_s =
      data_e
      .dataset['-']
    let list_s = ''
    for ( let lab_s of topics_s.split( ' ' ) )
    {
      list_s += `<li>${lab_s.replaceAll( '_', ' ' )}`
    }
    LIB_o
      .id__o( 'dialog_block_list' )
      .innerHTML = list_s
    const select_s =
      selected_b ?
        'NODE_BACK_SELECTED'
        :
        'NODE_BACK_NOT_SELECTED'
    LIB_o
      .rootVar__v
      (
        '--NODE_BACK',
        LIB_o
          .rootVar__s
            (
              `--${select_s}`
            ) 
      )
  }
,


  skin__v
  ()
  {
    if ( LIB_o.nodeId__o( 'section_skin' ) )  return    //: already loaded
    //->
    IND_o
      .load__v
      (
        path_s='sys',
        doc_s='skin',
        doc_n='-2',          //: negative indices for sys slots
        callback_f=null
      )
  }
,
  

  bookmark__v
  ()
  {
    if ( LIB_o.nodeId__o( 'section_bookmark' ) )  return    //: already loaded
    //->
    IND_o
      .load__v
      (
        path_s='sys',
        doc_s='bookmark',
        doc_n='-3',          //: negative indices for sys slots
        callback_f=null
      )
  }
,



  listen__v
  ()
  {
    GRA_o
      .slider_e
      .addEventListener
      (
        'click',
        GRA_o.nodes__v
      )
    GRA_o
      .svg_e
      .addEventListener
      (
        'click',
        GRA_o.nodeOpen__v
      )
    LIB_o
      .nodeId__o( 'skin_link' )
      .addEventListener
      (
        'click',
        _o =>    //: not used
        {
          GRA_o
            .skin__v()
        }
      )
    LIB_o
      .nodeId__o( 'bookmark_link' )
      .addEventListener
      (
        'click',
        _o =>    //: not used
        {
          GRA_o
            .bookmark__v()
        }
      )
    const section_e =
      SLOT_o
        .dialog__o( 'section_contents' )
    section_e
      .querySelector( 'dl' )
      .addEventListener
      (
        'click',
        GRA_o.nodeLink__v
        )
    LIB_o
      .id__o
      (
        'close',
        section_e
      )
      .addEventListener
      (
        'click',
        GRA_o.nodeClose__v
      )
  //: keyboard
  /*
  document.addEventListener( 'keyup',
    key_o =>
    {
      if ( key_o.defaultPrevented || !GRA_o.onv}iew__b() ) return
      //>
      const key_sn = key_o.key || key_o.keyCode
      if ( [ 'Escape', 'Esc', 27 ].includes( key_sn ) ||
           [ 'Backspace', 'Back', 8 ].includes( key_sn ) ) GRA_o.onview__s()    // ESC || BACKSPACE close
      else
      {
        switch ( true )
        {
          case ( [ 'ArrowLeft', 'Left', 37 ].includes( key_sn ) ) :    //: LEFT
            GRA_o.slider_c.toNearest__v( -1 )
            break
          case ( [ 'ArrowRight', 'Right', 39 ].includes( key_sn ) ) :    //: RIGHT
            GRA_o.slider_c.toNearest__v( 1 )
            break
          case ( [ 'ArrowUp', 'Up', 38 ].includes( key_sn ) ) :    //: UP
            GRA_o.slider_c.toNearest__v( -4 )
            break
          case ( [ 'ArrowDown', 'Down', 40 ].includes( key_sn ) ) :    //: DOWN
            GRA_o.slider_c.toNearest__v( 4 )
            break
          case ( [ 'Enter', 13 ].includes( key_sn ) ) :    //: ENTER
            GRA_o.onview__s()
            break
          default:
            break
        }
      }
      key_o.preventDefault()
      key_o.stopPropagation()
    }, true )
  */
  

  /*//XXXXXXXXXXXXXXXX
  document.querySelector( '[data-path]' )    //:!!! TEMPORARY: will be graph nodes
    .addEventListener( 'click',
      click_o =>
      {
        const path_s = click_o.target.dataset.path
        const doc_s = click_o.target.dataset.doc_s
        const step_n = GRA_o.slider_c.capacity__n()
        if ( !GRA_o.loaded__b( doc_s ) )
        {
          LIB_o.slot__v( path_s, doc_s, step_n,
           ( _e, section_e ) =>
           {
             section_e.dataset.doc_s = doc_s
             section_e.dataset.doc_n = step_n
             GRA_o.slider_c.add__v( section_e )
           } )
       
        }
        const view_s = GRA_o.onview__s()
        GRA_o.view__v( view_s )
      } )
      */
  
  }
,



}



void async function
()
{
  //...let json_o =
  //...  await GRA_o
  //...    .fetch__v( `http://127.0.0.1:8080/assets/data/json/graph.json` )
  //...GRA_o.graph_c =
  //...  Graph
  //...    .json__c( json_o )
  GRA_o.svg_e =
    LIB_o
      .nodeId__o( 'graph_svg' )
  GRA_o.slider_e =
    LIB_o
      .nodeId__o( 'graph_slider' )
  const topicsList_e =
    LIB_o
      .nodeId__o( 'topics_docs' )
  GRA_o.slider_c =
    new Slider3D
    (
      GRA_o.slider_e,
      topicsList_e,
    )
  LIB_o
    .rootVar__v
    (
      '--LABELS_CAP',
      topicsList_e.children.length
    )
  GRA_o
    .listen__v()
  //>
  ;console.log( 'graph.js' )
} ()


